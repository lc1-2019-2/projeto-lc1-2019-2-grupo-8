("mergesort" mergesort append_is_permutation 0 (append_is_permutation-1 nil 3781863044 ("" (induct "l1") (("1" (lemma "append_reverse_null") (("1" (skolem 1 "l2") (("1" (inst -1 "l2") (("1" (replace -1) (("1" (expand "permutations") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("v1" "tl1")) (("2" (flatten) (("2" (induct "l2") (("1" (expand "append" 1 2) (("1" (expand "append" 1) (("1" (inst -1 "null") (("1" (expand "permutations" 1) (("1" (skolem 1 "x") (("1" (case "x = v1") (("1" (expand "occurrences" 1) (("1" (assert) (("1" (expand "permutations" -2) (("1" (inst -2 "x") (("1" (expand "append" -2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences") (("2" (assert) (("2" (expand "permutations" -1) (("2" (inst -1 "x") (("2" (expand "append" -1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("v2" "tl2")) (("2" (flatten) (("2" (expand "append" 1) (("2" (expand "permutations" 1) (("2" (skolem 1 "x") (("2" (expand "occurrences" 1) (("2" (case "x = v1" "x = v2") (("1" (assert) (("1" (copy -2) (("1" (replace -2 -3) (("1" (lemma "append_occurrences") (("1" (inst-cp -1 "tl1" "cons(v2, tl2)" "x") (("1" (replace -2 1) (("1" (hide -2) (("1" (inst-cp -1 "tl2" "cons(v1, tl1)" "x") (("1" (replace -2 1) (("1" (hide -1 -2) (("1" (expand "occurrences" 1 (2 4)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "append_occurrences") (("2" (inst-cp -1 "tl1" "cons(v2, tl2)" "x") (("2" (replace -2 2) (("2" (hide -2) (("2" (inst-cp -1 "tl2" "cons(v1, tl1)" "x") (("2" (replace -2 2) (("2" (expand "occurrences" 2 (2 4)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "append_occurrences") (("3" (inst-cp -1 "tl1" "cons(v2, tl2)" "x") (("3" (replace -2 2) (("3" (hide -2) (("3" (inst-cp -1 "tl2" "cons(v1, tl1)" "x") (("3" (replace -2 2) (("3" (hide -2) (("3" (hide -1) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (hide 3) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 (2 4)) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 (2 4)) (("2" (lift-if) (("2" (prop) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (occurrences def-decl "nat" sorting_aux nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (append_occurrences formula-decl nil mergesort nil) (append_reverse_null formula-decl nil mergesort nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil mergesort nil) (append def-decl "list[T]" list_props nil) (permutations const-decl "bool" sorting_aux nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("mergesort" mergesort occurrence_pref_suff 0 (occurrence_pref_suff-1 nil 3782059771 ("" (lemma "app_prefix_suffix") (("" (skolem 1 "l") (("" (inst? -1) (("1" (skolem 1 "x") (("1" (replace -1 1) (("1" (lemma "append_occurrences") (("1" (inst? -1) (("1" (replace -1) (("1" (replace -2 1 RL) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "l = null") (("1" (replace -1 1) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (append_occurrences formula-decl nil mergesort nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (suffix def-decl "list[T]" sorting_aux nil) (prefix def-decl "list[T]" sorting_aux nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (l skolem-const-decl "list[T]" mergesort nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (app_prefix_suffix formula-decl nil sorting_aux nil) (T formal-type-decl nil mergesort nil)) shostak))("mergesort" mergesort app_pref_suff_is_complete 0 (app_pref_suff_is_complete-1 nil 3782060622 ("" (postpone) nil nil) nil shostak))("mergesort" mergesort app_pref_suff_is_complete_TCC1 0 (app_pref_suff_is_complete_TCC1-1 nil 3782060621 ("" (subtype-tcc) nil nil) nil nil))("mergesort" mergesort permutation_append_switch 0 (permutation_append_switch-1 nil 3781868900 ("" (induct "l1") (("1" (skolem 1 ("l" "l2")) (("1" (flatten) (("1" (lemma "append_reverse_null") (("1" (inst -1 "l2") (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem * ("v1" "tl1")) (("2" (flatten) (("2" (induct "l2") (("1" (skolem 1 "l") (("1" (flatten) (("1" (lemma "append_reverse_null") (("1" (inst -1 "cons(v1, tl1)") (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("v2" "tl2")) (("2" (flatten) (("2" (skolem 1 "l") (("2" (flatten) (("2" (expand "permutations" 1) (("2" (skolem 1 "x") (("2" (lemma "append_occurrences") (("2" (inst -1 "cons(v2, tl2)" "cons(v1, tl1)" "x") (("2" (replace -1 1) (("2" (expand "permutations" -3) (("2" (inst -3 "x") (("2" (replace -3 1) (("2" (hide -1) (("2" (lemma "append_occurrences") (("2" (inst -1 "cons(v1, tl1)" "cons(v2, tl2)" "x") (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (append_occurrences formula-decl nil mergesort nil) (append_reverse_null formula-decl nil mergesort nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil mergesort nil) (append def-decl "list[T]" list_props nil) (permutations const-decl "bool" sorting_aux nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("mergesort" mergesort merge_is_permutation_reverse 0 (merge_is_permutation_reverse-1 nil 3781866205 ("" (induct "l1") (("1" (lemma "append_reverse_null") (("1" (skolem 1 "l2") (("1" (inst -1 "l2") (("1" (replace -1) (("1" (expand "merge") (("1" (expand "permutations") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("v1" "tl1")) (("2" (flatten) (("2" (induct "l2") (("1" (expand "merge" 1) (("1" (lemma "append_reverse_null") (("1" (inst -1 "cons(v1, tl1)") (("1" (replace -1) (("1" (expand "permutations") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("v2" "tl2")) (("2" (flatten) (("2" (expand "permutations") (("2" (skolem 1 "x") (("2" (inst -1 "x") (("2" (lemma "merge_occurrence") (("2" (inst -1 "cons(v1, tl1)" "cons(v2, tl2)" "x") (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "append_occurrences") (("2" (inst -1 "cons(v2, tl2)" "cons(v1, tl1)" "x") (("2" (replace -1) (("2" (expand "occurrences" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (merge_occurrence formula-decl nil mergesort nil) (append_occurrences formula-decl nil mergesort nil) (occurrences def-decl "nat" sorting_aux nil) (append_reverse_null formula-decl nil mergesort nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil mergesort nil) (append def-decl "list[T]" list_props nil) (merge def-decl "list[T]" mergesort nil) (permutations const-decl "bool" sorting_aux nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("mergesort" mergesort append_occurrences 0 (append_occurrences-1 nil 3781704541 ("" (induct "l1") (("1" (skolem 1 ("l2" "x")) (("1" (expand "append") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skolem 1 ("v1" "tl1")) (("2" (flatten) (("2" (skolem 1 ("l2" "x")) (("2" (expand "append" 1) (("2" (expand "occurrences" 1 1) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 2) (("1" (lift-if) (("1" (assert) (("1" (inst -2 "l2" "x") nil nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (lift-if) (("2" (prop) (("2" (inst -1 "l2" "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil mergesort nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (append def-decl "list[T]" list_props nil) (occurrences def-decl "nat" sorting_aux nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("mergesort" mergesort append_reverse_null 0 (append_reverse_null-1 nil 3781693798 ("" (induct "l1") (("" (skolem 1 ("l1" "tl1")) (("" (flatten) (("" (expand "append" 1 1) (("" (replace -1 1) (("" (expand "append" 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil mergesort nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))